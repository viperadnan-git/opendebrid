// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: downloads.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDownload = `-- name: CreateDownload :one
INSERT INTO downloads (user_id, job_id)
VALUES ($1, $2)
RETURNING id, user_id, job_id, created_at
`

type CreateDownloadParams struct {
	UserID pgtype.UUID `json:"user_id"`
	JobID  pgtype.UUID `json:"job_id"`
}

func (q *Queries) CreateDownload(ctx context.Context, arg CreateDownloadParams) (Download, error) {
	row := q.db.QueryRow(ctx, createDownload, arg.UserID, arg.JobID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDownload = `-- name: DeleteDownload :exec
DELETE FROM downloads WHERE id = $1
`

func (q *Queries) DeleteDownload(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDownload, id)
	return err
}

const findDownloadByUserAndJobID = `-- name: FindDownloadByUserAndJobID :one
SELECT id, user_id, job_id, created_at FROM downloads
WHERE user_id = $1 AND job_id = $2
`

type FindDownloadByUserAndJobIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	JobID  pgtype.UUID `json:"job_id"`
}

func (q *Queries) FindDownloadByUserAndJobID(ctx context.Context, arg FindDownloadByUserAndJobIDParams) (Download, error) {
	row := q.db.QueryRow(ctx, findDownloadByUserAndJobID, arg.UserID, arg.JobID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const getDownloadByUserAndID = `-- name: GetDownloadByUserAndID :one
SELECT id, user_id, job_id, created_at FROM downloads WHERE id = $1 AND user_id = $2
`

type GetDownloadByUserAndIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetDownloadByUserAndID(ctx context.Context, arg GetDownloadByUserAndIDParams) (Download, error) {
	row := q.db.QueryRow(ctx, getDownloadByUserAndID, arg.ID, arg.UserID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const getDownloadWithJobAndCount = `-- name: GetDownloadWithJobAndCount :one
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.progress,
    j.speed,
    j.downloaded_size,

    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at,
    (SELECT count(*) FROM downloads d2 WHERE d2.job_id = d.job_id) AS download_count
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.id = $1 AND d.user_id = $2
`

type GetDownloadWithJobAndCountParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetDownloadWithJobAndCountRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Progress          float64            `json:"progress"`
	Speed             int64              `json:"speed"`
	DownloadedSize    int64              `json:"downloaded_size"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
	DownloadCount     int64              `json:"download_count"`
}

func (q *Queries) GetDownloadWithJobAndCount(ctx context.Context, arg GetDownloadWithJobAndCountParams) (GetDownloadWithJobAndCountRow, error) {
	row := q.db.QueryRow(ctx, getDownloadWithJobAndCount, arg.ID, arg.UserID)
	var i GetDownloadWithJobAndCountRow
	err := row.Scan(
		&i.DownloadID,
		&i.UserID,
		&i.JobID,
		&i.DownloadCreatedAt,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.JobCreatedAt,
		&i.JobUpdatedAt,
		&i.CompletedAt,
		&i.DownloadCount,
	)
	return i, err
}

const getDownloadWithJobByUser = `-- name: GetDownloadWithJobByUser :one
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.progress,
    j.speed,
    j.downloaded_size,

    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.id = $1 AND d.user_id = $2
`

type GetDownloadWithJobByUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetDownloadWithJobByUserRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Progress          float64            `json:"progress"`
	Speed             int64              `json:"speed"`
	DownloadedSize    int64              `json:"downloaded_size"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetDownloadWithJobByUser(ctx context.Context, arg GetDownloadWithJobByUserParams) (GetDownloadWithJobByUserRow, error) {
	row := q.db.QueryRow(ctx, getDownloadWithJobByUser, arg.ID, arg.UserID)
	var i GetDownloadWithJobByUserRow
	err := row.Scan(
		&i.DownloadID,
		&i.UserID,
		&i.JobID,
		&i.DownloadCreatedAt,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.JobCreatedAt,
		&i.JobUpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getUserDownloadStats = `-- name: GetUserDownloadStats :one
SELECT
    count(*) AS total,
    count(*) FILTER (WHERE j.status IN ('queued', 'active')) AS active,
    count(*) FILTER (WHERE j.status = 'completed') AS completed
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1
`

type GetUserDownloadStatsRow struct {
	Total     int64 `json:"total"`
	Active    int64 `json:"active"`
	Completed int64 `json:"completed"`
}

func (q *Queries) GetUserDownloadStats(ctx context.Context, userID pgtype.UUID) (GetUserDownloadStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserDownloadStats, userID)
	var i GetUserDownloadStatsRow
	err := row.Scan(&i.Total, &i.Active, &i.Completed)
	return i, err
}

const listDownloadsByUser = `-- name: ListDownloadsByUser :many
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.progress,
    j.speed,
    j.downloaded_size,

    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1
ORDER BY d.created_at DESC
LIMIT $2 OFFSET $3
`

type ListDownloadsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListDownloadsByUserRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Progress          float64            `json:"progress"`
	Speed             int64              `json:"speed"`
	DownloadedSize    int64              `json:"downloaded_size"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) ListDownloadsByUser(ctx context.Context, arg ListDownloadsByUserParams) ([]ListDownloadsByUserRow, error) {
	rows, err := q.db.Query(ctx, listDownloadsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDownloadsByUserRow{}
	for rows.Next() {
		var i ListDownloadsByUserRow
		if err := rows.Scan(
			&i.DownloadID,
			&i.UserID,
			&i.JobID,
			&i.DownloadCreatedAt,
			&i.NodeID,
			&i.Engine,
			&i.EngineJobID,
			&i.Url,
			&i.CacheKey,
			&i.Status,
			&i.Name,
			&i.Size,
			&i.FileLocation,
			&i.ErrorMessage,
			&i.Progress,
			&i.Speed,
			&i.DownloadedSize,
			&i.Metadata,
			&i.JobCreatedAt,
			&i.JobUpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadsByUserAndEngine = `-- name: ListDownloadsByUserAndEngine :many
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.progress,
    j.speed,
    j.downloaded_size,

    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1 AND j.engine = $2
ORDER BY d.created_at DESC
LIMIT $3 OFFSET $4
`

type ListDownloadsByUserAndEngineParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Engine string      `json:"engine"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListDownloadsByUserAndEngineRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Progress          float64            `json:"progress"`
	Speed             int64              `json:"speed"`
	DownloadedSize    int64              `json:"downloaded_size"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) ListDownloadsByUserAndEngine(ctx context.Context, arg ListDownloadsByUserAndEngineParams) ([]ListDownloadsByUserAndEngineRow, error) {
	rows, err := q.db.Query(ctx, listDownloadsByUserAndEngine,
		arg.UserID,
		arg.Engine,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDownloadsByUserAndEngineRow{}
	for rows.Next() {
		var i ListDownloadsByUserAndEngineRow
		if err := rows.Scan(
			&i.DownloadID,
			&i.UserID,
			&i.JobID,
			&i.DownloadCreatedAt,
			&i.NodeID,
			&i.Engine,
			&i.EngineJobID,
			&i.Url,
			&i.CacheKey,
			&i.Status,
			&i.Name,
			&i.Size,
			&i.FileLocation,
			&i.ErrorMessage,
			&i.Progress,
			&i.Speed,
			&i.DownloadedSize,
			&i.Metadata,
			&i.JobCreatedAt,
			&i.JobUpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserJobsWithDownloadCounts = `-- name: ListUserJobsWithDownloadCounts :many
SELECT
    d.id AS download_id,
    d.job_id,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.cache_key,
    j.status AS job_status,
    (SELECT count(*) FROM downloads d2 WHERE d2.job_id = d.job_id) AS download_count
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1
`

type ListUserJobsWithDownloadCountsRow struct {
	DownloadID    pgtype.UUID `json:"download_id"`
	JobID         pgtype.UUID `json:"job_id"`
	NodeID        string      `json:"node_id"`
	Engine        string      `json:"engine"`
	EngineJobID   pgtype.Text `json:"engine_job_id"`
	CacheKey      string      `json:"cache_key"`
	JobStatus     string      `json:"job_status"`
	DownloadCount int64       `json:"download_count"`
}

func (q *Queries) ListUserJobsWithDownloadCounts(ctx context.Context, userID pgtype.UUID) ([]ListUserJobsWithDownloadCountsRow, error) {
	rows, err := q.db.Query(ctx, listUserJobsWithDownloadCounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserJobsWithDownloadCountsRow{}
	for rows.Next() {
		var i ListUserJobsWithDownloadCountsRow
		if err := rows.Scan(
			&i.DownloadID,
			&i.JobID,
			&i.NodeID,
			&i.Engine,
			&i.EngineJobID,
			&i.CacheKey,
			&i.JobStatus,
			&i.DownloadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
