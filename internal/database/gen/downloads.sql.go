// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: downloads.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveDownloadsByUser = `-- name: CountActiveDownloadsByUser :one
SELECT count(*) FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1 AND j.status IN ('queued', 'active')
`

func (q *Queries) CountActiveDownloadsByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveDownloadsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCompletedDownloadsByUser = `-- name: CountCompletedDownloadsByUser :one
SELECT count(*) FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1 AND j.status = 'completed'
`

func (q *Queries) CountCompletedDownloadsByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCompletedDownloadsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDownloadsByJob = `-- name: CountDownloadsByJob :one
SELECT count(*) FROM downloads WHERE job_id = $1
`

func (q *Queries) CountDownloadsByJob(ctx context.Context, jobID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDownloadsByJob, jobID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDownloadsByUser = `-- name: CountDownloadsByUser :one
SELECT count(*) FROM downloads WHERE user_id = $1
`

func (q *Queries) CountDownloadsByUser(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDownloadsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDownload = `-- name: CreateDownload :one
INSERT INTO downloads (user_id, job_id)
VALUES ($1, $2)
RETURNING id, user_id, job_id, created_at
`

type CreateDownloadParams struct {
	UserID pgtype.UUID `json:"user_id"`
	JobID  pgtype.UUID `json:"job_id"`
}

func (q *Queries) CreateDownload(ctx context.Context, arg CreateDownloadParams) (Download, error) {
	row := q.db.QueryRow(ctx, createDownload, arg.UserID, arg.JobID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteDownload = `-- name: DeleteDownload :exec
DELETE FROM downloads WHERE id = $1
`

func (q *Queries) DeleteDownload(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDownload, id)
	return err
}

const findDownloadByUserAndJobID = `-- name: FindDownloadByUserAndJobID :one
SELECT id, user_id, job_id, created_at FROM downloads
WHERE user_id = $1 AND job_id = $2
`

type FindDownloadByUserAndJobIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	JobID  pgtype.UUID `json:"job_id"`
}

func (q *Queries) FindDownloadByUserAndJobID(ctx context.Context, arg FindDownloadByUserAndJobIDParams) (Download, error) {
	row := q.db.QueryRow(ctx, findDownloadByUserAndJobID, arg.UserID, arg.JobID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const getDownload = `-- name: GetDownload :one
SELECT id, user_id, job_id, created_at FROM downloads WHERE id = $1
`

func (q *Queries) GetDownload(ctx context.Context, id pgtype.UUID) (Download, error) {
	row := q.db.QueryRow(ctx, getDownload, id)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const getDownloadByUserAndID = `-- name: GetDownloadByUserAndID :one
SELECT id, user_id, job_id, created_at FROM downloads WHERE id = $1 AND user_id = $2
`

type GetDownloadByUserAndIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetDownloadByUserAndID(ctx context.Context, arg GetDownloadByUserAndIDParams) (Download, error) {
	row := q.db.QueryRow(ctx, getDownloadByUserAndID, arg.ID, arg.UserID)
	var i Download
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.JobID,
		&i.CreatedAt,
	)
	return i, err
}

const getDownloadWithJob = `-- name: GetDownloadWithJob :one
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.id = $1
`

type GetDownloadWithJobRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetDownloadWithJob(ctx context.Context, id pgtype.UUID) (GetDownloadWithJobRow, error) {
	row := q.db.QueryRow(ctx, getDownloadWithJob, id)
	var i GetDownloadWithJobRow
	err := row.Scan(
		&i.DownloadID,
		&i.UserID,
		&i.JobID,
		&i.DownloadCreatedAt,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Metadata,
		&i.JobCreatedAt,
		&i.JobUpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getDownloadWithJobByUser = `-- name: GetDownloadWithJobByUser :one
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.id = $1 AND d.user_id = $2
`

type GetDownloadWithJobByUserParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetDownloadWithJobByUserRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetDownloadWithJobByUser(ctx context.Context, arg GetDownloadWithJobByUserParams) (GetDownloadWithJobByUserRow, error) {
	row := q.db.QueryRow(ctx, getDownloadWithJobByUser, arg.ID, arg.UserID)
	var i GetDownloadWithJobByUserRow
	err := row.Scan(
		&i.DownloadID,
		&i.UserID,
		&i.JobID,
		&i.DownloadCreatedAt,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Metadata,
		&i.JobCreatedAt,
		&i.JobUpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listAllDownloadsByUser = `-- name: ListAllDownloadsByUser :many
SELECT id, user_id, job_id, created_at FROM downloads WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListAllDownloadsByUser(ctx context.Context, userID pgtype.UUID) ([]Download, error) {
	rows, err := q.db.Query(ctx, listAllDownloadsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Download{}
	for rows.Next() {
		var i Download
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.JobID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadsByUser = `-- name: ListDownloadsByUser :many
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1
ORDER BY d.created_at DESC
LIMIT $2 OFFSET $3
`

type ListDownloadsByUserParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListDownloadsByUserRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) ListDownloadsByUser(ctx context.Context, arg ListDownloadsByUserParams) ([]ListDownloadsByUserRow, error) {
	rows, err := q.db.Query(ctx, listDownloadsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDownloadsByUserRow{}
	for rows.Next() {
		var i ListDownloadsByUserRow
		if err := rows.Scan(
			&i.DownloadID,
			&i.UserID,
			&i.JobID,
			&i.DownloadCreatedAt,
			&i.NodeID,
			&i.Engine,
			&i.EngineJobID,
			&i.Url,
			&i.CacheKey,
			&i.Status,
			&i.Name,
			&i.Size,
			&i.FileLocation,
			&i.ErrorMessage,
			&i.Metadata,
			&i.JobCreatedAt,
			&i.JobUpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDownloadsByUserAndEngine = `-- name: ListDownloadsByUserAndEngine :many
SELECT
    d.id AS download_id,
    d.user_id,
    d.job_id,
    d.created_at AS download_created_at,
    j.node_id,
    j.engine,
    j.engine_job_id,
    j.url,
    j.cache_key,
    j.status,
    j.name,
    j.size,
    j.file_location,
    j.error_message,
    j.metadata,
    j.created_at AS job_created_at,
    j.updated_at AS job_updated_at,
    j.completed_at
FROM downloads d
JOIN jobs j ON j.id = d.job_id
WHERE d.user_id = $1 AND j.engine = $2
ORDER BY d.created_at DESC
LIMIT $3 OFFSET $4
`

type ListDownloadsByUserAndEngineParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Engine string      `json:"engine"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListDownloadsByUserAndEngineRow struct {
	DownloadID        pgtype.UUID        `json:"download_id"`
	UserID            pgtype.UUID        `json:"user_id"`
	JobID             pgtype.UUID        `json:"job_id"`
	DownloadCreatedAt pgtype.Timestamptz `json:"download_created_at"`
	NodeID            string             `json:"node_id"`
	Engine            string             `json:"engine"`
	EngineJobID       pgtype.Text        `json:"engine_job_id"`
	Url               string             `json:"url"`
	CacheKey          string             `json:"cache_key"`
	Status            string             `json:"status"`
	Name              string             `json:"name"`
	Size              pgtype.Int8        `json:"size"`
	FileLocation      pgtype.Text        `json:"file_location"`
	ErrorMessage      pgtype.Text        `json:"error_message"`
	Metadata          []byte             `json:"metadata"`
	JobCreatedAt      pgtype.Timestamptz `json:"job_created_at"`
	JobUpdatedAt      pgtype.Timestamptz `json:"job_updated_at"`
	CompletedAt       pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) ListDownloadsByUserAndEngine(ctx context.Context, arg ListDownloadsByUserAndEngineParams) ([]ListDownloadsByUserAndEngineRow, error) {
	rows, err := q.db.Query(ctx, listDownloadsByUserAndEngine,
		arg.UserID,
		arg.Engine,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDownloadsByUserAndEngineRow{}
	for rows.Next() {
		var i ListDownloadsByUserAndEngineRow
		if err := rows.Scan(
			&i.DownloadID,
			&i.UserID,
			&i.JobID,
			&i.DownloadCreatedAt,
			&i.NodeID,
			&i.Engine,
			&i.EngineJobID,
			&i.Url,
			&i.CacheKey,
			&i.Status,
			&i.Name,
			&i.Size,
			&i.FileLocation,
			&i.ErrorMessage,
			&i.Metadata,
			&i.JobCreatedAt,
			&i.JobUpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
