// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const batchUpdateJobProgress = `-- name: BatchUpdateJobProgress :exec
UPDATE jobs AS j SET
    progress = u.progress,
    speed = u.speed,
    downloaded_size = u.downloaded_size,
    name = COALESCE(NULLIF(u.name, ''), j.name),
    size = COALESCE(NULLIF(u.size, 0), j.size),
    status = 'active'
FROM (
    SELECT
        unnest($1::uuid[]) AS id,
        unnest($2::double precision[]) AS progress,
        unnest($3::bigint[]) AS speed,
        unnest($4::bigint[]) AS downloaded_size,
        unnest($5::text[]) AS name,
        unnest($6::bigint[]) AS size
) AS u
WHERE j.id = u.id AND j.status IN ('queued', 'active')
`

type BatchUpdateJobProgressParams struct {
	Ids            []pgtype.UUID `json:"ids"`
	Progress       []float64     `json:"progress"`
	Speed          []int64       `json:"speed"`
	DownloadedSize []int64       `json:"downloaded_size"`
	Name           []string      `json:"name"`
	Size           []int64       `json:"size"`
}

func (q *Queries) BatchUpdateJobProgress(ctx context.Context, arg BatchUpdateJobProgressParams) error {
	_, err := q.db.Exec(ctx, batchUpdateJobProgress,
		arg.Ids,
		arg.Progress,
		arg.Speed,
		arg.DownloadedSize,
		arg.Name,
		arg.Size,
	)
	return err
}

const completeJob = `-- name: CompleteJob :one
UPDATE jobs SET
    status = 'completed',
    engine_job_id = COALESCE(NULLIF($2, ''), engine_job_id),
    completed_at = NOW()
WHERE id = $1
RETURNING id, node_id, engine, engine_job_id, url, cache_key, status, name, size, file_location, error_message, progress, speed, downloaded_size, metadata, created_at, updated_at, completed_at
`

type CompleteJobParams struct {
	ID      pgtype.UUID `json:"id"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) CompleteJob(ctx context.Context, arg CompleteJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, completeJob, arg.ID, arg.Column2)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (node_id, engine, engine_job_id, url, cache_key, name)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, node_id, engine, engine_job_id, url, cache_key, status, name, size, file_location, error_message, progress, speed, downloaded_size, metadata, created_at, updated_at, completed_at
`

type CreateJobParams struct {
	NodeID      string      `json:"node_id"`
	Engine      string      `json:"engine"`
	EngineJobID pgtype.Text `json:"engine_job_id"`
	Url         string      `json:"url"`
	CacheKey    string      `json:"cache_key"`
	Name        string      `json:"name"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.NodeID,
		arg.Engine,
		arg.EngineJobID,
		arg.Url,
		arg.CacheKey,
		arg.Name,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const failJob = `-- name: FailJob :exec
UPDATE jobs SET
    status = 'failed',
    error_message = $2,
    file_location = NULL
WHERE id = $1
`

type FailJobParams struct {
	ID           pgtype.UUID `json:"id"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) FailJob(ctx context.Context, arg FailJobParams) error {
	_, err := q.db.Exec(ctx, failJob, arg.ID, arg.ErrorMessage)
	return err
}

const getJob = `-- name: GetJob :one
SELECT id, node_id, engine, engine_job_id, url, cache_key, status, name, size, file_location, error_message, progress, speed, downloaded_size, metadata, created_at, updated_at, completed_at FROM jobs WHERE id = $1
`

func (q *Queries) GetJob(ctx context.Context, id pgtype.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJob, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getJobByCacheKey = `-- name: GetJobByCacheKey :one
SELECT id, node_id, engine, engine_job_id, url, cache_key, status, name, size, file_location, error_message, progress, speed, downloaded_size, metadata, created_at, updated_at, completed_at FROM jobs WHERE cache_key = $1
`

func (q *Queries) GetJobByCacheKey(ctx context.Context, cacheKey string) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByCacheKey, cacheKey)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listActiveJobs = `-- name: ListActiveJobs :many
SELECT id, node_id, engine, engine_job_id, url, cache_key, status, name, size, file_location, error_message, progress, speed, downloaded_size, metadata, created_at, updated_at, completed_at FROM jobs
WHERE status IN ('queued', 'active')
ORDER BY created_at ASC
`

func (q *Queries) ListActiveJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.Query(ctx, listActiveJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Engine,
			&i.EngineJobID,
			&i.Url,
			&i.CacheKey,
			&i.Status,
			&i.Name,
			&i.Size,
			&i.FileLocation,
			&i.ErrorMessage,
			&i.Progress,
			&i.Speed,
			&i.DownloadedSize,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStorageKeysByNode = `-- name: ListStorageKeysByNode :many
SELECT DISTINCT cache_key FROM jobs
WHERE node_id = $1 AND status IN ('queued', 'active', 'completed')
`

func (q *Queries) ListStorageKeysByNode(ctx context.Context, nodeID string) ([]string, error) {
	rows, err := q.db.Query(ctx, listStorageKeysByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var cache_key string
		if err := rows.Scan(&cache_key); err != nil {
			return nil, err
		}
		items = append(items, cache_key)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE jobs SET
    status = $2,
    engine_job_id = COALESCE(NULLIF($3, ''), engine_job_id),
    error_message = $4,
    file_location = COALESCE(NULLIF($5, ''), file_location)
WHERE id = $1
RETURNING id, node_id, engine, engine_job_id, url, cache_key, status, name, size, file_location, error_message, progress, speed, downloaded_size, metadata, created_at, updated_at, completed_at
`

type UpdateJobStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	Column3      interface{} `json:"column_3"`
	ErrorMessage pgtype.Text `json:"error_message"`
	Column5      interface{} `json:"column_5"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJobStatus,
		arg.ID,
		arg.Status,
		arg.Column3,
		arg.ErrorMessage,
		arg.Column5,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Engine,
		&i.EngineJobID,
		&i.Url,
		&i.CacheKey,
		&i.Status,
		&i.Name,
		&i.Size,
		&i.FileLocation,
		&i.ErrorMessage,
		&i.Progress,
		&i.Speed,
		&i.DownloadedSize,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
