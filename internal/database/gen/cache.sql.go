// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cache.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCacheByNode = `-- name: DeleteCacheByNode :exec
DELETE FROM cache_entries WHERE node_id = $1
`

func (q *Queries) DeleteCacheByNode(ctx context.Context, nodeID string) error {
	_, err := q.db.Exec(ctx, deleteCacheByNode, nodeID)
	return err
}

const deleteCacheEntry = `-- name: DeleteCacheEntry :exec
DELETE FROM cache_entries WHERE cache_key = $1
`

func (q *Queries) DeleteCacheEntry(ctx context.Context, cacheKey string) error {
	_, err := q.db.Exec(ctx, deleteCacheEntry, cacheKey)
	return err
}

const insertCacheEntry = `-- name: InsertCacheEntry :one
INSERT INTO cache_entries (cache_key, job_id, node_id, engine, file_location, total_size)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (cache_key) DO UPDATE SET
    last_accessed = NOW(),
    access_count = cache_entries.access_count + 1
RETURNING cache_key, job_id, node_id, engine, file_location, total_size, created_at, last_accessed, access_count
`

type InsertCacheEntryParams struct {
	CacheKey     string      `json:"cache_key"`
	JobID        pgtype.UUID `json:"job_id"`
	NodeID       string      `json:"node_id"`
	Engine       string      `json:"engine"`
	FileLocation string      `json:"file_location"`
	TotalSize    pgtype.Int8 `json:"total_size"`
}

func (q *Queries) InsertCacheEntry(ctx context.Context, arg InsertCacheEntryParams) (CacheEntry, error) {
	row := q.db.QueryRow(ctx, insertCacheEntry,
		arg.CacheKey,
		arg.JobID,
		arg.NodeID,
		arg.Engine,
		arg.FileLocation,
		arg.TotalSize,
	)
	var i CacheEntry
	err := row.Scan(
		&i.CacheKey,
		&i.JobID,
		&i.NodeID,
		&i.Engine,
		&i.FileLocation,
		&i.TotalSize,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.AccessCount,
	)
	return i, err
}

const listCacheByLRU = `-- name: ListCacheByLRU :many
SELECT cache_key, job_id, node_id, engine, file_location, total_size, created_at, last_accessed, access_count FROM cache_entries
ORDER BY last_accessed ASC
LIMIT $1
`

func (q *Queries) ListCacheByLRU(ctx context.Context, limit int32) ([]CacheEntry, error) {
	rows, err := q.db.Query(ctx, listCacheByLRU, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CacheEntry{}
	for rows.Next() {
		var i CacheEntry
		if err := rows.Scan(
			&i.CacheKey,
			&i.JobID,
			&i.NodeID,
			&i.Engine,
			&i.FileLocation,
			&i.TotalSize,
			&i.CreatedAt,
			&i.LastAccessed,
			&i.AccessCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lookupCache = `-- name: LookupCache :one
SELECT cache_key, job_id, node_id, engine, file_location, total_size, created_at, last_accessed, access_count FROM cache_entries WHERE cache_key = $1
`

func (q *Queries) LookupCache(ctx context.Context, cacheKey string) (CacheEntry, error) {
	row := q.db.QueryRow(ctx, lookupCache, cacheKey)
	var i CacheEntry
	err := row.Scan(
		&i.CacheKey,
		&i.JobID,
		&i.NodeID,
		&i.Engine,
		&i.FileLocation,
		&i.TotalSize,
		&i.CreatedAt,
		&i.LastAccessed,
		&i.AccessCount,
	)
	return i, err
}

const touchCache = `-- name: TouchCache :exec
UPDATE cache_entries SET
    last_accessed = NOW(),
    access_count = access_count + 1
WHERE cache_key = $1
`

func (q *Queries) TouchCache(ctx context.Context, cacheKey string) error {
	_, err := q.db.Exec(ctx, touchCache, cacheKey)
	return err
}
